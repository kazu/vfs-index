// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package query

import "github.com/kazu/fbshelper/query/base"

type InvertedMapStringList struct { // genny
	*CommonNode
}

// InvertedMapString genny
func NewInvertedMapStringList() *InvertedMapStringList {

	list := emptyInvertedMapStringList()
	list.NodeList = &base.NodeList{}
	list.CommonNode.Name = "[]InvertedMapString"

	(*base.List)(list.CommonNode).InitList()
	return list
}

func emptyInvertedMapStringList() *InvertedMapStringList {
	return &InvertedMapStringList{CommonNode: &base.CommonNode{}}
}

func (node InvertedMapStringList) At(i int) (result *InvertedMapString, e error) {
	result = &InvertedMapString{}
	result.CommonNode, e = (*base.List)(node.CommonNode).At(i)
	return
}

func (node InvertedMapStringList) AtWihoutError(i int) (result *InvertedMapString) {
	result, e := node.At(i)
	if e != nil {
		result = nil
	}
	return
}

func (node InvertedMapStringList) SetAt(i int, v *InvertedMapString) error {
	return (*base.List)(node.CommonNode).SetAt(i, v.CommonNode)
}
func (node InvertedMapStringList) Add(v InvertedMapStringList) error {
	return (*base.List)(node.CommonNode).Add((*base.List)(v.CommonNode))
}

func (node InvertedMapStringList) Range(start, last int) *InvertedMapStringList {
	l := (*base.List)(node.CommonNode).New(base.OptRange(start, last))
	if l == nil {
		return nil
	}
	return &InvertedMapStringList{CommonNode: (*base.CommonNode)(l)}
}

func (node InvertedMapStringList) First() (result *InvertedMapString, e error) {
	return node.At(0)
}

func (node InvertedMapStringList) Last() (result *InvertedMapString, e error) {
	return node.At(int(node.NodeList.ValueInfo.VLen) - 1)
}

func (node InvertedMapStringList) Select(fn func(*InvertedMapString) bool) (result []*InvertedMapString) {
	result = make([]*InvertedMapString, 0, int(node.NodeList.ValueInfo.VLen))
	commons := (*base.List)(node.CommonNode).Select(func(cm *CommonNode) bool {
		return fn(&InvertedMapString{CommonNode: cm})
	})
	for _, cm := range commons {
		result = append(result, &InvertedMapString{CommonNode: cm})
	}
	return result
}

func (node InvertedMapStringList) Find(fn func(*InvertedMapString) bool) *InvertedMapString {
	result := &InvertedMapString{}
	result.CommonNode = (*base.List)(node.CommonNode).Find(func(cm *CommonNode) bool {
		return fn(&InvertedMapString{CommonNode: cm})
	})
	return result
}

func (node InvertedMapStringList) All() []*InvertedMapString {
	return node.Select(func(*InvertedMapString) bool { return true })
}

func (node InvertedMapStringList) Count() int {
	return int(node.NodeList.ValueInfo.VLen)
}

func (node InvertedMapStringList) SwapAt(i, j int) error {
	return (*List)(node.CommonNode).SwapAt(i, j)
}

func (node InvertedMapStringList) SortBy(less func(i, j int) bool) error {
	return (*List)(node.CommonNode).SortBy(less)
}

// Search ... binary search
func (node InvertedMapStringList) Search(fn func(*InvertedMapString) bool) *InvertedMapString {
	result := &InvertedMapString{}

	i := (*base.List)(node.CommonNode).SearchIndex(int((*base.List)(node.CommonNode).VLen()), func(cm *CommonNode) bool {
		return fn(&InvertedMapString{CommonNode: cm})
	})
	if i < int((*base.List)(node.CommonNode).VLen()) {
		result, _ = node.At(i)
	}

	return result
}

func (node InvertedMapStringList) SearchIndex(fn func(*InvertedMapString) bool) int {

	i := (*base.List)(node.CommonNode).SearchIndex(int((*base.List)(node.CommonNode).VLen()), func(cm *CommonNode) bool {
		return fn(&InvertedMapString{CommonNode: cm})
	})
	if i < int((*base.List)(node.CommonNode).VLen()) {
		return i
	}

	return -1
}
